install.packages("ggplot2")
install.packages("plyr")
library(ggplot2)
library(plyr)
library(reshape2)
install.packages("RWeka")
require(ISLR)
require(ISLR)
require(boot)
?cv.glm
plot(mpg~horsepower,data=Auto)
## LOOCV
glm.fit=glm(mpg~horsepower, data=Auto)
cv.glm(Auto,glm.fit)$delta #pretty slow (doesnt use formula (5.2) on page 180)
##Lets write a simple function to use formula (5.2)
loocv=function(fit){
h=lm.influence(fit)$h
mean((residuals(fit)/(1-h))^2)
}
## Now we try it out
loocv(glm.fit)
cv.error=rep(0,5)
degree=1:5
for(d in degree){
glm.fit=glm(mpg~poly(horsepower,d), data=Auto)
cv.error[d]=loocv(glm.fit)
}
plot(degree,cv.error,type="b")
## 10-fold CV
cv.error10=rep(0,5)
for(d in degree){
glm.fit=glm(mpg~poly(horsepower,d), data=Auto)
cv.error10[d]=cv.glm(Auto,glm.fit,K=10)$delta[1]
}
lines(degree,cv.error10,type="b",col="red")
## Bootstrap
## Minimum risk investment - Section 5.2
alpha=function(x,y){
vx=var(x)
vy=var(y)
cxy=cov(x,y)
(vy-cxy)/(vx+vy-2*cxy)
}
alpha(Portfolio$X,Portfolio$Y)
## What is the standard error of alpha?
alpha.fn=function(data, index){
with(data[index,],alpha(X,Y))
}
alpha.fn(Portfolio,1:100)
set.seed(1)
alpha.fn (Portfolio,sample(1:100,100,replace=TRUE))
boot.out=boot(Portfolio,alpha.fn,R=1000)
boot.out
plot(boot.out)
load("Dropbox/Doctorate/Results/MachineLearning/5.R.RData")
colnames(Xy) <- c("X", "XX", "Y")
Xy
names(Xy)
alpha.fn(Xy,1:100)
alpha.fn(Xy,1:1000)
boot.out=boot(Xy,alpha.fn,R=1000)
boot.out
plot(boot.out)
alpha.fn(Xy,1:1000)
boot.out=boot(Xy,alpha.fn,R=1000)
boot.out
plot(boot.out)
summary(lm(y~.,data=Xy))
Xy
Xy
fit = lm(Xy$y~Xy$X1 + Xy$X2,data = Xy)
summary(fit)
fit = lm(Xy$y~Xy$X1 + Xy$X2,data = Xy)
summary(fit)
fit = lm(Xy$y~Xy$X1 + Xy$X2,data = Xy)
fit <- lm(Xy$y~Xy$X1 + Xy$X2,data = Xy)
load("Dropbox/Doctorate/Results/MachineLearning/5.R.RData")
fit <- lm(Xy$y~Xy$X1 + Xy$X2,data = Xy)
summary(fit)
fit <- lm(Xy$y~Xy$X1,data = Xy)
summary(fit)
fit <- lm(Xy$y~.,Xy$X1)
fit <- lm(Xy$y~.,data = Xy)
summary(fit)
matplot(Xy,type="l")
fit <- lm(Xy$y~.-1,data = Xy)
summary(fit)
alpha.fn(Xy,1:100)
boot.out=boot(Xy,alpha.fn,R=1000)
boot.out
plot(boot.out)
require(ISLR)
require(boot)
?cv.glm
plot(mpg~horsepower,data=Auto)
## LOOCV
glm.fit=glm(mpg~horsepower, data=Auto)
cv.glm(Auto,glm.fit)$delta #pretty slow (doesnt use formula (5.2) on page 180)
##Lets write a simple function to use formula (5.2)
loocv=function(fit){
h=lm.influence(fit)$h
mean((residuals(fit)/(1-h))^2)
}
## Now we try it out
loocv(glm.fit)
cv.error=rep(0,5)
degree=1:5
for(d in degree){
glm.fit=glm(mpg~poly(horsepower,d), data=Auto)
cv.error[d]=loocv(glm.fit)
}
plot(degree,cv.error,type="b")
## 10-fold CV
cv.error10=rep(0,5)
for(d in degree){
glm.fit=glm(mpg~poly(horsepower,d), data=Auto)
cv.error10[d]=cv.glm(Auto,glm.fit,K=10)$delta[1]
}
lines(degree,cv.error10,type="b",col="red")
## Bootstrap
## Minimum risk investment - Section 5.2
alpha=function(x,y){
vx=var(x)
vy=var(y)
cxy=cov(x,y)
(vy-cxy)/(vx+vy-2*cxy)
}
alpha(Portfolio$X,Portfolio$Y)
## What is the standard error of alpha?
alpha.fn=function(data, index){
with(data[index,],alpha(X,Y))
}
alpha.fn(Portfolio,1:100)
set.seed(1)
alpha.fn (Portfolio,sample(1:100,100,replace=TRUE))
boot.out=boot(Portfolio,alpha.fn,R=1000)
boot.out
plot(boot.out)
alpha.fn(Xy,1:100)
boot.out=boot(Xy,alpha.fn,R=1000)
boot.out
plot(boot.out)
alpha.fn(Xy,1:100)
alpha.fn(Xy,1:100)
Xy
names(Xy)
require(ISLR)
require(boot)
?cv.glm
plot(mpg~horsepower,data=Auto)
## LOOCV
glm.fit=glm(mpg~horsepower, data=Auto)
cv.glm(Auto,glm.fit)$delta #pretty slow (doesnt use formula (5.2) on page 180)
##Lets write a simple function to use formula (5.2)
loocv=function(fit){
h=lm.influence(fit)$h
mean((residuals(fit)/(1-h))^2)
}
## Now we try it out
loocv(glm.fit)
cv.error=rep(0,5)
degree=1:5
for(d in degree){
glm.fit=glm(mpg~poly(horsepower,d), data=Auto)
cv.error[d]=loocv(glm.fit)
}
plot(degree,cv.error,type="b")
## 10-fold CV
cv.error10=rep(0,5)
for(d in degree){
glm.fit=glm(mpg~poly(horsepower,d), data=Auto)
cv.error10[d]=cv.glm(Auto,glm.fit,K=10)$delta[1]
}
lines(degree,cv.error10,type="b",col="red")
## Bootstrap
## Minimum risk investment - Section 5.2
alpha=function(x,y){
vx=var(x)
vy=var(y)
cxy=cov(x,y)
(vy-cxy)/(vx+vy-2*cxy)
}
alpha(Portfolio$X,Portfolio$Y)
## What is the standard error of alpha?
alpha.fn=function(data, index){
with(data[index,],alpha(X,Y))
}
alpha.fn(Portfolio,1:100)
set.seed(1)
alpha.fn (Portfolio,sample(1:100,100,replace=TRUE))
boot.out=boot(Portfolio,alpha.fn,R=1000)
boot.out
plot(boot.out)
load("Dropbox/Doctorate/Results/MachineLearning/5.R.RData")
alpha.fn(Xy,1:100)
colnames(Xy) <- c("X", "XX", "Y")
alpha.fn(Xy,1:100)
boot.out=boot(Xy,alpha.fn,R=1000)
boot.out
plot(boot.out)
new.rows = c(101:200, 401:500, 101:200, 901:1000, 301:400, 1:100, 1:100, 801:900, 201:300, 701:800)
new.Xy = Xy[new.rows, ]
alpha(Xy$X, Xy$Y)
alpha.fn(Portfolio,1:100)
alpha.fn (Xy,sample(1:100,100,replace=TRUE))
sample(1:100,100,replace=TRUE)
alpha.fn (Xy,1:100)
alpha.fn (Xy,1:1000)
alpha.fn (Xy,1:100)
alpha.fn (new.Xy ,1:100)
summary(lm(y~.,data=Xy))
summary(lm(Xy$Y~.,data=Xy))
library(glmnet)
library(glmnet)
library(ISLR)
summary(Hitters)
Hitters = na.omit(Hitters)
with(Hitters, sum(is.na(Salary))
)
library(leaps)
regfit.full = regsubsets(Salary ~ ., data = Hitters)
summary(regfit.full)
dim(Hitters)
x = model.matrix(Salary ~ . - 1, data = Hitters)
y = Hitters$Salary
fit.ridge = glmnet(x, y, alpha = 0)
fit.ridge
?cv.glmnet
summary(fit.ridge)
Dir <- "/home/marcos/chameleon_tutorial/spack/pajeng/b"
setwd(Dir)
library(ggplot2)
library(plyr)
choose_palette <- function(bw) {
if(bw) {
myPalette <- c("#252525", "#525252", "#737373", "#969696", "#bdbdbd", "#d9d9d9", "#f0f0f0")
myPalette <- myPalette[c(1,6,2,5,4,3,7)]
} else {
library(RColorBrewer)
myPalette <- brewer.pal(8, "Set1");
myPalette <- myPalette[c(1,2,3,4,5,7,8)]
}
myPalette
}
myPalette <- choose_palette(black_white)
###############################
# Function for reading gflops rates from a simple .csv file
read_gflops <- function(file, name) {
df<-read.table(file, header=FALSE)
df$Origin <- name
df$Size <- as.numeric(df$V1)
df$GFlops <- as.numeric(df$V5)
df <- df[,c("Origin","Size","GFlops")]
df
}
###############################
# Function for reading gflops rates from a simple .csv file
read_residual <- function(file, name) {
df<-read.table(file, header=FALSE)
df$Origin <- name
df$Size <- as.numeric(df$V1)
df$Residual <- as.numeric(df$V8) /
(as.numeric(df$V9) * (as.numeric(df$V10))  + (as.numeric(df$V11)))
df <- df[,c("Origin","Size","Residual")]
df
}
# Function for plotting gflops rates
gflops_plot <- function(df, title="Comparing GFlops rates", points=FALSE, lines=FALSE, bars=TRUE, bar_width=160, limits=FALSE, ymin=0, ymax=1500) {
plot <- ggplot(df, aes(x = Size, y = GFlops, color=Origin, fill=Origin)) + theme_bw() + ggtitle(title) + ylab("GFlops") + xlab("Matrix dimension") + guides(color = guide_legend(title = "Experimental\nCondition"), fill = guide_legend(title = "Experimental\nCondition"))
if (points==TRUE)
plot <- plot + geom_point()
if (lines==TRUE)
plot <- plot + geom_line()
if (bars==TRUE)
plot <- plot + geom_bar(stat = "identity", position="dodge", width=bar_width)
# Add limits to the x and y axis
if (limits==TRUE)
plot <- plot + scale_x_continuous("Matrix dimension", limits = c(0,80000), breaks = c(0,20000,40000,60000,80000), labels = c("0","20K","40K","60K","80K")) + ylim(ymin,ymax)
plot
}
# Function for plotting residuals
residual_plot <- function(df, title="Comparing residuals", points=FALSE, lines=FALSE, bars=TRUE, bar_width=160, limits=FALSE, ymin=0, ymax=1500) {
plot <- ggplot(df, aes(x = Size, y = Residual, color=Origin, fill=Origin)) + theme_bw() + ggtitle(title) + ylab("Residual") + xlab("Matrix dimension") + guides(color = guide_legend(title = "Experimental\nCondition"), fill = guide_legend(title = "Experimental\nCondition"))
if (points==TRUE)
plot <- plot + geom_point()
if (lines==TRUE)
plot <- plot + geom_line()
if (bars==TRUE)
plot <- plot + geom_bar(stat = "identity", position="dodge", width=bar_width)
# Add limits to the x and y axis
if (limits==TRUE)
plot <- plot + scale_x_continuous("Matrix dimension", limits = c(0,80000), breaks = c(0,20000,40000,60000,80000), labels = c("0","20K","40K","60K","80K")) + ylim(ymin,ymax)
plot
}
# Function for reading standard paje traces (dumped to .csv by pj_dump)
read_trace_wh <- function(file, name) {
df<-read.table(file, header=TRUE, sep=",", strip.white=TRUE, fill=TRUE)
#names(df) <- c("Nature","ResourceId","Type","Start","End","Duration", "Depth", "Value","Footprint","JobId","Params","Size","Tag")
df = df[!(names(df) %in% c("Nature","Type", "Depth", "Footprint", "Params", "Size"))]
df$Origin=name
m <- min(df$Start)
df$Start <- df$Start - m
df$End <- df$Start+df$Duration
df
}
# Function for plotting comparison of two paje plots
paje_plot <- function(df, title="Comparing traces", tasks_only=FALSE) {
# Defining and filtering less important states (if necessary)
if (tasks_only){
def_states<-c("Initializing", "Deinitializing", "Overhead", "Nothing", "Sleeping", "Freeing", "Allocating", "WritingBack", "FetchingInput", "PushingOutput", "Callback", "Progressing", "Unpartitioning", "AllocatingReuse", "Reclaiming", "DriverCopy", "DriverCopyAsync", "Scheduling", "Executing", "Idle")
df<-df[!(df$Value %in% def_states),]
}
ggplot(df,aes(x=Start,xend=End, y=factor(ResourceId), yend=factor(ResourceId),color=Value)) + theme_bw() + geom_segment(size=8) + ggtitle(title) + ylab("Resource") + xlab("Time [ms]") + facet_wrap(~Origin,ncol=1,scale="free_y") + guides(color = guide_legend(title = "State"))
## + guides(color=guide_legend(ncol=8, title = "State")) +
## theme(legend.position="bottom")
}
##############################
# Part for the advanced analysis
add_iterations <- function (df) {
df_kmn = df
df_kmn$k=""
df_kmn$m=""
df_kmn$n=""
df_kmn$Tag <- as.character(df_kmn$Tag)
df_kmn[df_kmn$Value=="dpotrf",]$k <- as.hexmode(substr(df_kmn[df_kmn$Value=="dpotrf",]$Tag, 14, 16))
#potrf: ..000k STARPU_TAG_ONLY, (starpu_tag_t) (Am)
df_kmn[df_kmn$Value=="dtrsm",]$k <- as.hexmode(substr(df_kmn[df_kmn$Value=="dtrsm",]$Tag, 11, 13))
df_kmn[df_kmn$Value=="dtrsm",]$m <- as.hexmode(substr(df_kmn[df_kmn$Value=="dtrsm",]$Tag, 14, 16))
# trsm: ..000k 000m STARPU_TAG_ONLY, (starpu_tag_t) (Bm * 0x10000 + Bn)
df_kmn[df_kmn$Value=="dsyrk",]$k <- as.hexmode(substr(df_kmn[df_kmn$Value=="dsyrk",]$Tag, 8, 10))
df_kmn[df_kmn$Value=="dsyrk",]$n <- as.hexmode(substr(df_kmn[df_kmn$Value=="dsyrk",]$Tag, 11, 13))
df_kmn[df_kmn$Value=="dsyrk",]$m <- as.hexmode(substr(df_kmn[df_kmn$Value=="dsyrk",]$Tag, 14, 16))
# herk(transfered to syrk): ..000k 000n 000m STARPU_TAG_ONLY, (starpu_tag_t) (((Am * 0x1000) + Cm )* 0x1000 + Cn)
df_kmn[df_kmn$Value=="dgemm",]$k <- as.hexmode(substr(df_kmn[df_kmn$Value=="dgemm",]$Tag, 8, 10))
df_kmn[df_kmn$Value=="dgemm",]$n <- as.hexmode(substr(df_kmn[df_kmn$Value=="dgemm",]$Tag, 11, 13))
df_kmn[df_kmn$Value=="dgemm",]$m <- as.hexmode(substr(df_kmn[df_kmn$Value=="dgemm",]$Tag, 14, 16))
# gemm: ..000k 000n 000m STARPU_TAG_ONLY, (starpu_tag_t) (((Am * 0x1000) + Cm )* 0x1000 + Cn)
df_kmn
}
get_dependencies <- function(file){
id_depends <- read.csv(file, head=F, sep=",", col.names = c("JobId", "DependsOn"), na.strings="")
id_depends$DependsOn = as.character(id_depends$DependsOn)
id_depends[is.na(id_depends)]<-"0"
tmpList <- strsplit(as.character(id_depends$DependsOn), "[ ]+")
n<-lapply(tmpList, length)
R<-rep(as.vector(id_depends$JobId), as.vector(unlist(n)))
tmpdf<-data.frame(R, as.numeric(unlist(tmpList)))
names(tmpdf)<-c("JobId","Dependent")
tmpdf
}
clean_replicas <- function(df){
df$DepStart = lapply(df[,"Dependent"], function (id, dataframe) return (dataframe[dataframe$JobId == id,]$Start), dataframe = unique(df[,c("JobId", "Start", "End")]))
df$DepStart = as.numeric(df$DepStart)
df$DepEnd = lapply(df[,"Dependent"], function (id, dataframe) return (dataframe[dataframe$JobId == id,]$End), dataframe = unique(df[,c("JobId", "Start", "End")]))
df$DepEnd = as.numeric(df$DepEnd)
df$ResourceId = as.character(df$ResourceId)
df$DepResourceId = lapply(df[,"Dependent"], function(id, dataframe) return (dataframe[dataframe$JobId == id,]$ResourceId), dataframe= unique(df[,c("JobId", "Start", "End","ResourceId")]))
df$ResourceId = as.factor(df$ResourceId)
df$DepResourceId = as.character(df$DepResourceId)
df$DepResourceId = as.factor(df$DepResourceId)
df = unique(df)
df
}
# 2.1. Real experiments
# 2.1.1 Experiments on the homogeneous node
df <- read_gflops("homogeneous_gflops_out", "Homogeneous native")
gflops_plot(df, bars=FALSE, points=TRUE, lines=TRUE)
df <- read_residual("homogeneous_gflops_out", "Homogeneous native")
residual_plot(df, bars=FALSE, points=TRUE, lines=TRUE)
df <- read_trace_wh("homogeneous_paje.csv","Homogeneous native trace")
paje_plot(df, title="", tasks_only=TRUE)
# 2.1.2 Experiments on the heterogeneous node
df <- read_gflops("heterogeneous_gflops_out", "Heterogeneous native")
gflops_plot(df, bars=FALSE, points=TRUE, lines=TRUE)
df <- read_residual("heterogeneous_gflops_out", "Heterogeneous native")
residual_plot(df, bars=FALSE, points=TRUE, lines=TRUE)
df <- read_trace_wh("heterogeneous_paje.csv","Heterogeneous native trace")
paje_plot(df, title="", tasks_only=TRUE)
# 2.2 Simulation - SimGrid
## df1 <- read_gflops("heterogeneous_gflops_out", "Native")
## df2 <- read_gflops("gflops_simgrid", "SimGrid")
## df <- rbind(df1, df2)
df <- read_gflops("gflops_simgrid", "SimGrid")
# Taking only certain executions into account (if necessary)
#df<-df[df$Origin %in% c("Native", "Simulation"),]
gflops_plot(df, bars=TRUE, points=FALSE, lines=FALSE)
df1 <- read_trace_wh("heterogeneous_paje.csv","Native trace")
df2 <- read_trace_wh("paje_simgrid.csv","SimGrid trace")
df <- rbind(df1,df2)
## df <- read_trace_wh("paje_simgrid.csv","SimGrid trace")
paje_plot(df)
# 2.3 Scheduling
df <- read_trace_wh("homogeneous_paje.csv","Homogeneous native trace")
paje_plot(df, title="", tasks_only=TRUE)
df
View(df)
df <- read_trace_wh("heterogeneous_paje.csv","Heterogeneous native trace")
paje_plot(df, title="", tasks_only=TRUE)
dirpath <- "~/Dropbox/Doctorate/Results/2016/svm-gpuperf/data/"
setwd(paste(dirpath, sep=""))
cbbPalette <- gray(1:6/ 8)#c("red", "blue", "darkgray", "orange","black","brown", "lightblue","violet")
tracesName  <- read.csv(paste("./tracesName.csv",sep=","),header = TRUE)
SSM_Traces_HtoD_TeslaK40  <- as.matrix(read.csv(paste("./Tesla-K40/Subseqmax-HtoD-traces.csv",sep=","),header = FALSE, col.names = names(tracesName)))
SSM_Traces_HtoD_980  <- as.matrix(read.csv(paste("./GeForce-980/Subseqmax-HtoD-traces.csv",sep=","),header = FALSE, col.names = names(tracesName)))
SSM_Traces_HtoD_750  <- as.matrix(read.csv(paste("./GeForce-750/Subseqmax-HtoD-traces.csv",sep=","),header = FALSE, col.names = names(tracesName)))
SSM_Traces_DtoH_TeslaK40  <- as.matrix(read.csv(paste("./Tesla-K40/vectorAdd-DtoH-traces.csv",sep=","),header = FALSE), col.names = names(tracesName))
SSM_Traces_DtoH_980  <- as.matrix(read.csv(paste("./GeForce-980/vectorAdd-DtoH-traces.csv",sep=","),header = FALSE, col.names = names(tracesName)))
SSM_Traces_DtoH_750  <- as.matrix(read.csv(paste("./GeForce-750/vectorAdd-DtoH-traces.csv",sep=","),header = FALSE), col.names = names(tracesName))
SSM_Traces_DtoH_TeslaK40  <- as.matrix(read.csv(paste("./Tesla-K40/vectorAdd-DtoH-traces.csv",sep=","),header = FALSE), col.names = names(tracesName))
SSM_Traces_HtoD_TeslaK40  <- as.matrix(read.csv(paste("./Tesla-K40/Subseqmax-HtoD-traces.csv",sep=","),header = FALSE, col.names = names(tracesName)))
SSM_Traces_HtoD_TeslaK40  <- as.matrix(read.csv(paste("./Tesla-K40/Subseqmax-HtoD-traces.csv",sep=","),header = FALSE, col.names = names(tracesName)))
dirpath <- "~/Dropbox/Doctorate/Results/2016/svm-gpuperf/data/"
setwd(paste(dirpath, sep=""))
SSM_Traces_HtoD_TeslaK40  <- as.matrix(read.csv(paste("./Tesla-K40/Subseqmax-HtoD-traces.csv",sep=","),header = FALSE, col.names = names(tracesName)))
SSM_Traces_HtoD_TeslaK40  <- as.matrix(read.csv(paste("./Tesla-K40/vectorTrans-HtoD-traces.csv",sep=","),header = FALSE, col.names = names(tracesName)))
dirpath <- "~/Dropbox/Doctorate/Results/2016/svm-gpuperf/data/"
setwd(paste(dirpath, sep=""))
cbbPalette <- gray(1:6/ 8)#c("red", "blue", "darkgray", "orange","black","brown", "lightblue","violet")
tracesName  <- read.csv(paste("./tracesName.csv",sep=","),header = TRUE)
SSM_Traces_HtoD_TeslaK40  <- as.matrix(read.csv(paste("./Tesla-K40/vectorTrans-HtoD-traces.csv",sep=","),header = FALSE, col.names = names(tracesName)))
SSM_Traces_HtoD_980  <- as.matrix(read.csv(paste("./GeForce-980/vectorTrans-HtoD-traces.csv",sep=","),header = FALSE, col.names = names(tracesName)))
SSM_Traces_HtoD_750  <- as.matrix(read.csv(paste("./GeForce-750/vectorTrans-HtoD-traces.csv",sep=","),header = FALSE, col.names = names(tracesName)))
SSM_Traces_DtoH_TeslaK40  <- as.matrix(read.csv(paste("./Tesla-K40/vectorTrans-DtoH-traces.csv",sep=","),header = FALSE), col.names = names(tracesName))
SSM_Traces_DtoH_980  <- as.matrix(read.csv(paste("./GeForce-980/vectorTrans-DtoH-traces.csv",sep=","),header = FALSE, col.names = names(tracesName)))
SSM_Traces_DtoH_750  <- as.matrix(read.csv(paste("./GeForce-750/vectorTrans-DtoH-traces.csv",sep=","),header = FALSE), col.names = names(tracesName))
